{
  "hash": "ed0d75f24f4aeebfbcd0c0ecd0299b51",
  "result": {
    "markdown": "---\ntitle: \"R Nuts and Bolts\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to data types and objects in R\"\ndate: 2022-09-22\ndraft: true\ncategories: [module 4, week 4, R, programming]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://rafalab.github.io/dsbook/r-basics>\n2. <https://r4ds.had.co.nz/vectors.html?q=typeof#vectors>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-r-nuts-and-bolts>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Know the 5 basic built-in data types (or classes) of objects in R\n- Know the types of attributes (or metadata) R objects can have\n- Be able to create a vector, matrix, data frame, factor, and list in R \n- Recognize missing values in R\n\n:::\n\n# R Nuts and Bolts\n\n## Entering Input\n\nAt the R prompt we type expressions. The `<-` symbol is the assignment\noperator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmsg <- \"hello\"\n```\n:::\n\n\nThe grammar of the language determines whether an expression is\ncomplete or not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <-  ## Incomplete expression\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:2:0: unexpected end of input\n1: x <-  ## Incomplete expression\n   ^\n```\n:::\n:::\n\n\nThe `#` character indicates a comment. Anything to the right of the `#`\n(including the `#` itself) is ignored. This is the only comment\ncharacter in R. Unlike some other languages, R does not support\nmulti-line comments or comment blocks.\n\n\n## Evaluation\n\nWhen a complete expression is entered at the prompt, it is evaluated\nand the result of the evaluated expression is returned. The result may\nbe **auto-printed**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5  ## nothing printed\nx       ## auto-printing occurs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nprint(x)  ## explicit printing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nThe `[1]` shown in the output indicates that `x` is a vector and `5`\nis its first element. \n\nTypically with interactive work, we do not explicitly print objects\nwith the `print` function; it is much easier to just auto-print them\nby typing the name of the object and hitting return/enter. However,\nwhen writing scripts, functions, or longer programs, there is\nsometimes a need to explicitly print objects because auto-printing\ndoes not work in those settings.\n\nWhen an R vector is printed you will notice that an index for the\nvector is printed in square brackets `[]` on the side. For example,\nsee this integer sequence of length 20.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 11:30\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20 21 22\n[13] 23 24 25 26 27 28 29 30\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nThe numbers in the square brackets are not part of the vector itself,\nthey are merely part of the **printed output**. \n\nWith R, it's important that one understand that there is a difference\nbetween the actual R object and the manner in which that R object is\nprinted to the console. Often, the printed output may have additional\nbells and whistles to make the output more friendly to the\nusers. However, these bells and whistles are not inherently part of\nthe object.\n\nNote that the `:` operator is used to create integer sequences.\n\n\n## R Objects\n\nR has five basic or [\"atomic\" classes of vector objects](https://r4ds.had.co.nz/vectors.html?q=typeof#vector-basics):\n\n-   **logical**: `FALSE`, `TRUE`, and `NA`\n-   **numeric**: real numbers\n-   **integer** (and doubles): these are known collectively as numeric vectors\n-   **complex**: complex numbers\n-   **character**: the most complex type of atomic vector, because each element of a character vector is a string, and a string can contain an arbitrary amount of data.\n\n\n![](https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png){.preview-image}\n\n[**Source**: [R 4 Data Science](https://r4ds.had.co.nz/vectors.html?q=typeof#vector-basics)]\n\n### Numerics\n\nInteger and double vectors are known collectively as numeric vectors. In R, numbers are doubles by default. To make an integer, place an `L` after the number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1.5L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n\n:::{.callout-tip}\n\n### Note \n\nThe distinction between integers and doubles is not usually important, but there are two important differences that you should be aware of:\n\n- Doubles are approximations. \n- Doubles represent floating point numbers that can not always be precisely represented with a fixed amount of memory. This means that you should consider all doubles to be approximations. \n\nFor example, what is square of the square root of two?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sqrt(2) ^ 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nx - 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.440892e-16\n```\n:::\n:::\n\n\n:::\n\nThe most basic type of R object is a vector. Empty vectors can be\ncreated with the `vector()` function.  There is really only one rule\nabout vectors in R, which is that \n**A vector can only contain objects of the same class**.\n\nFor example, if you run this, what happens? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector(\"a\", 1)\n```\n:::\n\n\nBut of course, like any good rule, there is an exception, which is a\n**list**, which we will get to a bit later. A list is represented as a\nvector but can contain objects of different classes. Indeed, that's\nusually why we use them.\n\nThere is also a class for \"raw\" objects, but they are not commonly\nused directly in data analysis and I won't cover them here.\n\n\n## Numbers\n\nNumbers in R are generally treated as numeric objects (i.e. double\nprecision real numbers). This means that even if you see a number like\n\"1\" or \"2\" in R, which you might think of as integers, they are likely\nrepresented behind the scenes as numeric objects (so something like\n\"1.00\" or \"2.00\"). This isn't important most of the time...except when\nit is.\n\nIf you explicitly want an integer, you need to specify the `L`\nsuffix. So entering `1` in R gives you a numeric object; entering `1L`\nexplicitly gives you an integer object.\n\nThere is also a special number `Inf` which represents infinity. This\nallows us to represent entities like `1 / 0`. This way, `Inf` can be\nused in ordinary calculations; e.g. `1 / Inf` is 0.\n\nThe value `NaN` represents an undefined value (\"not a number\"); e.g. 0\n/ 0; `NaN` can also be thought of as a missing value (more on that\nlater)\n\n\n## Attributes\n\nR objects can have attributes, which are like metadata for the\nobject. These metadata can be very useful in that they help to\ndescribe the object. For example, column names on a data frame help to\ntell us what data are contained in each of the columns. Some examples\nof R object attributes are\n\n-   names, dimnames\n-   dimensions (e.g. matrices, arrays)\n-   class (e.g. integer, numeric)\n-   length\n-   other user-defined attributes/metadata\n\nAttributes of an object (if any) can be accessed using the\n`attributes()` function. Not all R objects contain attributes, in\nwhich case the `attributes()` function returns `NULL`.\n\nHowever, every **vector** has two key properties:\n\n1. Its **type**, which you can determine with `typeof()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n2. Its **length**, which you can determine with `length()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"a\", \"b\", 1:10)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\n\n## Creating Vectors\n\nThe `c()` function can be used to create vectors of objects by\nconcatenating things together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0.5, 0.6)       ## numeric\nx <- c(TRUE, FALSE)    ## logical\nx <- c(T, F)           ## logical\nx <- c(\"a\", \"b\", \"c\")  ## character\nx <- 9:29              ## integer\nx <- c(1+0i, 2+4i)     ## complex\n```\n:::\n\n\nNote that in the above example, `T` and `F` are short-hand ways to\nspecify `TRUE` and `FALSE`. However, in general one should try to use\nthe explicit `TRUE` and `FALSE` values when indicating logical\nvalues. The `T` and `F` values are primarily there for when you're\nfeeling lazy.\n\nYou can also use the `vector()` function to initialize vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(\"numeric\", length = 10) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 0 0 0 0 0\n```\n:::\n:::\n\n\n## Mixing Objects\n\nThere are occasions when different classes of R objects get mixed\ntogether. Sometimes this happens by accident but it can also happen on\npurpose. So what happens with the following code?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1.7, \"a\")   ## character\ny <- c(TRUE, 2)    ## numeric\ny <- c(\"a\", TRUE)  ## character\n```\n:::\n\n\nIn each case above, we are mixing objects of two different classes in\na vector. But remember that the only rule about vectors says this is\nnot allowed. When different objects are mixed in a vector, _coercion_\noccurs so that every element in the vector is of the same class.\n\nIn the example above, we see the effect of *implicit coercion*. What R\ntries to do is find a way to represent all of the objects in the\nvector in a reasonable fashion. Sometimes this does exactly what you\nwant and...sometimes not. For example, combining a numeric object with\na character object will create a character vector, because numbers can\nusually be easily represented as strings.\n\n\n## Explicit Coercion\n\nObjects can be explicitly coerced from one class to another using the\n`as.*` functions, if available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0:6\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nas.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n```\n:::\n:::\n\n\nSometimes, R can't figure out how to coerce an object and this can\nresult in `NA`s being produced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\")\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n\n```{.r .cell-code}\nas.complex(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n:::\n\n\nWhen nonsensical coercion takes place, you will usually get a warning\nfrom R.\n\n\n## Matrices\n\nMatrices are vectors with a _dimension_ attribute. The dimension\nattribute is itself an integer vector of length 2 (number of rows,\nnumber of columns)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(nrow = 2, ncol = 3) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n```\n:::\n\n```{.r .cell-code}\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nattributes(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 2 3\n```\n:::\n:::\n\n\nMatrices are constructed _column-wise_, so entries can be thought of\nstarting in the \"upper left\" corner and running down the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:6, nrow = 2, ncol = 3) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\n\nMatrices can also be created directly from vectors by adding a\ndimension attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- 1:10 \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\ndim(m) <- c(2, 5)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n:::\n:::\n\n\nMatrices can be created by _column-binding_ or _row-binding_ with the\n`cbind()` and `rbind()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\ny <- 10:12\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x  y\n[1,] 1 10\n[2,] 2 11\n[3,] 3 12\n```\n:::\n\n```{.r .cell-code}\nrbind(x, y) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3]\nx    1    2    3\ny   10   11   12\n```\n:::\n:::\n\n\n## Lists\n\nLists are a special type of **vector** that can contain elements of\ndifferent classes. Lists are a very important data type in R and you\nshould get to know them well. Lists, in combination with the various\n\"apply\" functions discussed later, make for a powerful combination.\n\nLists can be explicitly created using the `list()` function, which\ntakes an arbitrary number of arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1, \"a\", TRUE, 1 + 4i) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n[[4]]\n[1] 1+4i\n```\n:::\n:::\n\n\nWe can also create an empty list of a prespecified length with the\n`vector()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(\"list\", length = 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n\n[[5]]\nNULL\n```\n:::\n:::\n\n\n## Factors\n\nFactors are used to represent categorical data and can be unordered or\nordered. One can think of a factor as an integer vector where each\ninteger has a _label_. Factors are important in statistical modeling\nand are treated specially by modelling functions like `lm()` and\n`glm()`.\n\nUsing factors with labels is _better_ than using integers because\nfactors are self-describing. Having a variable that has values \"Yes\"\nand \"No\" or \"Smoker\" and \"Non-Smoker\" is better than a variable that has values 1 and 2.\n\nFactor objects can be created with the `factor()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\")) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: no yes\n```\n:::\n\n```{.r .cell-code}\ntable(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx\n no yes \n  2   3 \n```\n:::\n\n```{.r .cell-code}\n## See the underlying representation of factor\nunclass(x)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 1 2 1\nattr(,\"levels\")\n[1] \"no\"  \"yes\"\n```\n:::\n:::\n\n\nOften factors will be automatically created for you when you read a\ndataset in using a function like `read.table()`. Those functions often\ndefault to creating factors when they encounter data that look like\ncharacters or strings.\n\nThe order of the levels of a factor can be set using the `levels`\nargument to `factor()`. This can be important in linear modelling\nbecause the first level is used as the baseline level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\"))\nx  ## Levels are put in alphabetical order\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: no yes\n```\n:::\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\"),\n            levels = c(\"yes\", \"no\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: yes no\n```\n:::\n:::\n\n\n## Missing Values\n\nMissing values are denoted by `NA` or `NaN` for q undefined\nmathematical operations.\n\n- `is.na()` is used to test objects if they are `NA`\n\n- `is.nan()` is used to test for `NaN`\n\n- `NA` values have a class also, so there are integer `NA`, character\n  `NA`, etc.\n\n- A `NaN` value is also `NA` but the converse is not true\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create a vector with NAs in it\nx <- c(1, 2, NA, 10, 3)  \n## Return a logical vector indicating which elements are NA\nis.na(x)    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n## Return a logical vector indicating which elements are NaN\nis.nan(x)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Now create a vector with both NA and NaN values\nx <- c(1, 2, NaN, NA, 4)\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nis.nan(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n## Data Frames\n\nData frames are used to store tabular data in R. They are an important\ntype of object in R and are used in a variety of statistical modeling\napplications. Hadley Wickham's package\n[dplyr](https://github.com/hadley/dplyr) has an optimized set of\nfunctions designed to work efficiently with data frames.\n\nData frames are represented as a special type of list where every\nelement of the list has to have the same length. Each element of the\nlist can be thought of as a column and the length of each element of\nthe list is the number of rows.\n\nUnlike matrices, data frames can store different classes of objects in\neach column. Matrices must have every element be the same class\n(e.g. all integers or all numeric).\n\nIn addition to column names, indicating the names of the variables or\npredictors, data frames have a special attribute called `row.names`\nwhich indicate information about each row of the data frame.\n\nData frames are usually created by reading in a dataset using the\n`read.table()` or `read.csv()`. However, data frames can also be\ncreated explicitly with the `data.frame()` function or they can be\ncoerced from other types of objects like lists.\n\nData frames can be converted to a matrix by calling\n`data.matrix()`. While it might seem that the `as.matrix()` function\nshould be used to coerce a data frame to a matrix, almost always, what\nyou want is the result of `data.matrix()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(foo = 1:4, bar = c(T, T, F, F)) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  foo   bar\n1   1  TRUE\n2   2  TRUE\n3   3 FALSE\n4   4 FALSE\n```\n:::\n\n```{.r .cell-code}\nnrow(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nncol(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n## Names\n\nR objects can have names, which is very useful for writing readable\ncode and self-describing objects. Here is an example of assigning\nnames to an integer vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nnames(x) <- c(\"New York\", \"Seattle\", \"Los Angeles\") \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   New York     Seattle Los Angeles \n          1           2           3 \n```\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"New York\"    \"Seattle\"     \"Los Angeles\"\n```\n:::\n:::\n\n\nLists can also have names, which is often very useful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"Los Angeles\" = 1, Boston = 2, London = 3) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`Los Angeles`\n[1] 1\n\n$Boston\n[1] 2\n\n$London\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Los Angeles\" \"Boston\"      \"London\"     \n```\n:::\n:::\n\n\nMatrices can have both column and row names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:4, nrow = 2, ncol = 2)\ndimnames(m) <- list(c(\"a\", \"b\"), c(\"c\", \"d\")) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  c d\na 1 3\nb 2 4\n```\n:::\n:::\n\n\nColumn names and row names can be set separately using the\n`colnames()` and `rownames()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(m) <- c(\"h\", \"f\")\nrownames(m) <- c(\"x\", \"z\")\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  h f\nx 1 3\nz 2 4\n```\n:::\n:::\n\n\nNote that for data frames, there is a separate function for setting\nthe row names, the `row.names()` function. Also, data frames do not\nhave column names, they just have names (like lists). So to set the\ncolumn names of a data frame just use the `names()` function. Yes, I\nknow its confusing. Here's a quick summary:\n\n| Object | Set column names | Set row names |\n| ------ | ---------------- | ------------- |\n| data frame | `names()` | `row.names()` |\n| matrix | `colnames()` | `rownames()` |\n\n\n# Summary\n\nThere are a variety of different builtin-data types in R. In this\nchapter we have reviewed the following\n\n- atomic classes: numeric, logical, character, integer, complex\n- vectors, lists\n- factors\n- missing values\n- data frames and matrices\n\nAll R objects can have attributes that help to describe what is in the\nobject. Perhaps the most useful attribute is names, such as column and\nrow names in a data frame, or simply names in a vector or\nlist. Attributes like dimensions are also important as they can modify\nthe behavior of objects, like turning a vector into a matrix.\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1. Describe the difference between is.finite(x) and !is.infinite(x).\n\n2. A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research.\n\n3. What functions from the readr package allow you to turn a string into logical, integer, and double vector?\n\n4. Try and make a tibble that has columns with different lengths. What happens?\n\n:::\n\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://rdpeng.github.io/Biostat776/lecture-r-nuts-and-bolts>\n- <https://rafalab.github.io/dsbook/r-basics>\n- <https://r4ds.had.co.nz/vectors.html?q=typeof#vectors>\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}