{
  "hash": "713119fbd8b574aeab3b463c61dbee48",
  "result": {
    "markdown": "---\ntitle: \"Control Structures\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to control the flow of execution of a series of R expressions\"\ndate: 2022-09-22\ndraft: true\ncategories: [module 4, week 4, R, programming]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1. <https://rafalab.github.io/dsbook/programming-basics>\n2. <https://r4ds.had.co.nz/iteration>\n\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n- <https://rdpeng.github.io/Biostat776/lecture-control-structures>\n- <https://r4ds.had.co.nz/iteration>\n\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n- Be able to use commonly used control structures including `if`, `while`, `repeat`, and `for`\n- Be able to skip an iteration of a loop using `next`\n- Be able to exit a loop immediately using `break`\n\n:::\n\n# Control Structures\n\nControl structures in R allow you to control the flow of execution of\na series of R expressions. Basically, control structures allow you to\nput some \"logic\" into your R code, rather than just always executing\nthe same R code every time. Control structures allow you to respond to\ninputs or to features of the data and execute different R expressions\naccordingly.\n\nCommonly used control structures are\n\n- `if` and `else`: testing a condition and acting on it\n\n- `for`: execute a loop a fixed number of times \n\n- `while`: execute a loop _while_ a condition is true \n\n- `repeat`: execute an infinite loop (must `break` out of it to stop)\n\n- `break`: break the execution of a loop\n\n- `next`: skip an interation of a loop\n\nMost control structures are not used in interactive sessions, but\nrather when writing functions or longer expresisons. However, these\nconstructs do not have to be used in functions and it's a good idea to\nbecome familiar with them before we delve into functions.\n\n\n## `if`-`else`\n\nThe `if`-`else` combination is probably the most commonly used control\nstructure in R (or perhaps any language). This structure allows you to\ntest a condition and act on it depending on whether it's true or\nfalse. \n\nFor starters, you can just use the `if` statement.\n\n```r\nif(<condition>) {\n        ## do something\n} \n## Continue with rest of code\n```\n\nThe above code does nothing if the condition is false. If you have an\naction you want to execute when the condition is false, then you need\nan `else` clause.\n\n```r\nif(<condition>) {\n        ## do something\n} \nelse {\n        ## do something else\n}\n```\n\nYou can have a series of tests by following the initial `if` with any\nnumber of `else if`s.\n\n```r\nif(<condition1>) {\n        ## do something\n} else if(<condition2>)  {\n        ## do something different\n} else {\n        ## do something different\n}\n```\n\nHere is an example of a valid if/else structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Generate a uniform random number\nx <- runif(1, 0, 10)  \nif(x > 3) {\n        y <- 10\n} else {\n        y <- 0\n}\n```\n:::\n\n\nThe value of `y` is set depending on whether `x > 3` or not. This\nexpression can also be written a different, but equivalent, way in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- if(x > 3) {\n        10\n} else { \n        0\n}\n```\n:::\n\n\nNeither way of writing this expression is more correct than the\nother. Which one you use will depend on your preference and perhaps\nthose of the team you may be working with.\n\nOf course, the `else` clause is not necessary. You could have a series\nof if clauses that always get executed if their respective conditions\nare true.\n\n```r\nif(<condition1>) {\n\n}\n\nif(<condition2>) {\n\n}\n```\n\n\n## `for` Loops\n\nFor loops are pretty much the only looping construct that you will\nneed in R. While you may occasionally find a need for other types of\nloops, in my experience doing data analysis, I've found very few\nsituations where a for loop wasn't sufficient. \n\nIn R, for loops take an interator variable and assign it successive\nvalues from a sequence or vector. For loops are most commonly used for\niterating over the elements of an object (list, vector, etc.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10) {\n        print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n:::\n:::\n\n\nThis loop takes the `i` variable and in each iteration of the loop\ngives it values 1, 2, 3, ..., 10, executes the code within the curly\nbraces, and then the loop exits.\n\nThe following three loops all have the same behavior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\", \"d\")\n\nfor(i in 1:4) {\n        ## Print out each element of 'x'\n        print(x[i])  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nThe `seq_along()` function is commonly used in conjunction with for\nloops in order to generate an integer sequence based on the length of\nan object (in this case, the object `x`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Generate a sequence based on length of 'x'\nfor(i in seq_along(x)) {   \n        print(x[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nIt is not necessary to use an index-type variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(letter in x) {\n        print(letter)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nFor one line loops, the curly braces are not strictly necessary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:4) print(x[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nHowever, I like to use curly braces even for one-line loops, because\nthat way if you decide to expand the loop to multiple lines, you won't\nbe burned because you forgot to add curly braces (and you *will* be\nburned by this).\n\n\n## Nested `for` loops\n\n`for` loops can be nested inside of each other.\n\n```r\nx <- matrix(1:6, 2, 3)\n\nfor(i in seq_len(nrow(x))) {\n        for(j in seq_len(ncol(x))) {\n                print(x[i, j])\n        }   \n}\n```\n\nNested loops are commonly needed for multidimensional or hierarchical\ndata structures (e.g. matrices, lists). Be careful with nesting\nthough. Nesting beyond 2 to 3 levels often makes it difficult to\nread/understand the code. If you find yourself in need of a large\nnumber of nested loops, you may want to break up the loops by using\nfunctions (discussed later).\n\n\n## `while` Loops\n\nWhile loops begin by testing a condition. If it is true, then they\nexecute the loop body. Once the loop body is executed, the condition\nis tested again, and so forth, until the condition is false, after\nwhich the loop exits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount <- 0\nwhile(count < 10) {\n        print(count)\n        count <- count + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n```\n:::\n:::\n\n\nWhile loops can potentially result in infinite loops if not written\nproperly. Use with care!\n\nSometimes there will be more than one condition in the test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 5\nset.seed(1)\n\nwhile(z >= 3 && z <= 10) {\n        coin <- rbinom(1, 1, 0.5)\n        \n        if(coin == 1) {  ## random walk\n                z <- z + 1\n        } else {\n                z <- z - 1\n        } \n}\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nConditions are always evaluated from left to right. For example, in\nthe above code, if `z` were less than 3, the second test would not\nhave been evaluated.\n\n\n\n## `repeat` Loops\n\n`repeat` initiates an infinite loop right from the start. These are\nnot commonly used in statistical or data analysis applications but\nthey do have their uses. The only way to exit a `repeat` loop is to\ncall `break`.\n\nOne possible paradigm might be in an iterative algorithm where you may\nbe searching for a solution and you don't want to stop until you're\nclose enough to the solution. In this kind of situation, you often\ndon't know in advance how many iterations it's going to take to get\n\"close enough\" to the solution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx0 <- 1\ntol <- 1e-8\n\nrepeat {\n        x1 <- computeEstimate()\n        \n        if(abs(x1 - x0) < tol) {  ## Close enough?\n                break\n        } else {\n                x0 <- x1\n        } \n}\n```\n:::\n\n\nNote that the above code will not run if the `computeEstimate()`\nfunction is not defined (I just made it up for the purposes of this\ndemonstration).\n\nThe loop above is a bit dangerous because there's no guarantee it will\nstop. You could get in a situation where the values of `x0` and `x1`\noscillate back and forth and never converge. Better to set a hard\nlimit on the number of iterations by using a `for` loop and then\nreport whether convergence was achieved or not.\n\n\n## `next`, `break`\n\n`next` is used to skip an iteration of a loop. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:100) {\n        if(i <= 20) {\n                ## Skip the first 20 iterations\n                next                 \n        }\n        ## Do something here\n}\n```\n:::\n\n\n`break` is used to exit a loop immediately, regardless of what\niteration the loop may be on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:100) {\n      print(i)\n\n      if(i > 20) {\n              ## Stop loop after 20 iterations\n              break  \n      }\t\t\n}\n```\n:::\n\n\n\n# Summary\n\n- Control structures like `if`, `while`, and `for` allow you to\n  control the flow of an R program\n- Infinite loops should generally be avoided, even if (you believe)\n  they are theoretically correct.\n- Control structures mentioned here are primarily useful for writing\n  programs; for command-line interactive work, the \"apply\" functions\n  are more useful.\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1. Write for loops to compute the mean of every column in `mtcars`.\n\n2. Imagine you have a directory full of CSV files that you want to read in. You have their paths in a vector, `files <- dir(\"data/\", pattern = \"\\\\.csv$\", full.names = TRUE)`, and now want to read each one with `read_csv()`. Write the for loop that will load them into a single data frame.\n\n3. What happens if you use `for (nm in names(x))` and `x` has no names? What if only some of the elements are named? What if the names are not unique?\n\n:::\n\n### Additional Resources\n\n::: callout-tip\n\n- <https://rdpeng.github.io/Biostat776/lecture-control-structures>\n- <https://rafalab.github.io/dsbook/programming-basics>\n- <https://r4ds.had.co.nz/iteration>\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}